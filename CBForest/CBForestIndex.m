//
//  CBForestIndex.m
//  CBForest
//
//  Created by Jens Alfke on 4/1/14.
//  Copyright (c) 2014 Couchbase. All rights reserved.
//

#import "CBForestIndex.h"
#import "CBForestPrivate.h"
#import "CBCollatable.h"
#import "varint.h"
#import <forestdb.h>


id kCBForestIndexNoValue;


@implementation CBForestIndex


+ (void) initialize {
    if (!kCBForestIndexNoValue)
        kCBForestIndexNoValue = [[NSObject alloc] init];
}


- (BOOL) setKeys: (NSArray*)keys
          values: (NSArray*)values
     forDocument: (NSString*)docID
      atSequence: (CBForestSequence)docSequence
           error: (NSError**)outError
{
    return [self inTransaction: ^BOOL {
        // Remove any old key/value pairs previously generated by this document:
        NSData* docIDData = CBCreateCollatable(docID);
        NSData* oldSeqData;
        if (![self getValue: &oldSeqData meta: NULL forKey: docIDData error: outError])
            return NO;
        if (oldSeqData) {
            // Decode a series of sequences from packed varint data:
            slice seqBuf = DataToSlice(oldSeqData);
            uint64_t seq;
            while (ReadUVarInt(&seqBuf, &seq)) {
                // ...and delete the old key/values with those sequences:
                [self deleteSequence: seq error: NULL];
            }
        }

        // Add the key/value pairs:
        NSData* newSeqData = nil;
        NSUInteger count = keys.count;
        if (count > 0) {
            NSMutableArray* seqs = [[NSMutableArray alloc] initWithCapacity: count];
            NSMutableData* keyData = [NSMutableData dataWithCapacity: 1024];
            for (NSUInteger i = 0; i < count; i++) {
                @autoreleasepool {
                    keyData.length = 0;
                    CBCollatableBeginArray(keyData);
                    CBAddCollatable(keys[i], keyData);
                    CBAddCollatable(docID, keyData);
                    CBAddCollatable(@(docSequence), keyData);
                    CBCollatableEndArray(keyData);

                    NSData* bodyData;
                    id value = values[i];
                    if (value != kCBForestIndexNoValue) {
                        bodyData = JSONToData(value, NULL);
                        if (!bodyData) {
                            NSLog(@"WARNING: Can't index non-JSON value %@", value);
                            continue;
                        }
                    } else {
                        // Can't use an empty value or ForestDB will just delete the doc instead
                        // (MB-10915)
                        bodyData = [[NSData alloc] initWithBytes: "\0" length: 1];
                    }

                    CBForestSequence seq = [self setValue: bodyData
                                                     meta: nil
                                                   forKey: keyData
                                                    error: outError];
                    if (seq == kCBForestNoSequence)
                        return NO;
                    [seqs addObject: @(seq)];
                    //NSLog(@"INDEX: Seq %llu = %@ --> %@", seq, keyData, body);
                }
            }

            // Encode the new sequences into a packed series of varints:
            NSMutableData* seqData = [NSMutableData dataWithLength: seqs.count*kMaxVarintLen64];
            slice seqBuf = DataToSlice(seqData);
            for (NSNumber* seq in seqs)
                WriteUVarInt(&seqBuf, seq.unsignedLongLongValue);
            seqData.length = seqBuf.buf - seqData.mutableBytes;
            newSeqData = seqData;
        } else {
            newSeqData = nil;
        }

        // Update the list of sequences used for this document:
        if (oldSeqData || newSeqData) {
            CBForestSequence seq = [self setValue: newSeqData
                                             meta: nil
                                           forKey: docIDData
                                            error: outError];
            return seq != kCBForestNoSequence;
        } else {
            return YES;
        }
    }];
}


- (BOOL) queryStartKey: (id)startKey
            startDocID: (NSString*)startDocID
                endKey: (id)endKey
              endDocID: (NSString*)endDocID
               options: (const CBForestEnumerationOptions*)options
                 error: (NSError**)outError
                 block: (CBForestQueryCallbackBlock)block
{
    // Remember, the underlying keys are of the form [emittedKey, docID, serial#]
    NSMutableArray* realStartKey = [NSMutableArray arrayWithObjects: startKey, startDocID, nil];
    NSMutableArray* realEndKey = [NSMutableArray arrayWithObjects: endKey, endDocID, nil];
    NSMutableArray* maxKey = (options && options->descending) ? realStartKey : realEndKey;
    [maxKey addObject: @{}];

    return [self _enumerateValuesFromKey: CBCreateCollatable(realStartKey)
                                   toKey: CBCreateCollatable(realEndKey)
                                 options: options
                                   error: outError
                               withBlock: ^BOOL(fdb_doc *doc, uint64_t bodyOffset)
    {
        @autoreleasepool {
            if (!Check([self rawGetBody: doc byOffset: bodyOffset], outError)) {
                fdb_doc_free(doc);
                return false;
            }

            // Decode the key from collatable form:
            slice indexKey = {doc->key, doc->keylen};
            id key;
            NSString* docID;
            int64_t docSequence;
            CBCollatableReadNext(&indexKey, NO, &key); // array marker
            CBCollatableReadNext(&indexKey, YES, &key);
            CBCollatableReadNext(&indexKey, NO, &docID);
            CBCollatableReadNextNumber(&indexKey, &docSequence);

            // Decode the value:
            // if there's no value, the body will be just a null byte (MB-10915)
            NSData* valueData = nil;
            if (doc->bodylen > 1)
                valueData = SliceToData(doc->body, doc->bodylen);
            fdb_doc_free(doc);

            if (options && !options->inclusiveEnd && endKey && [endKey isEqual: key]) {
                return false;
            }
            BOOL stop = NO;
            block(key, valueData, docID, docSequence, &stop);
            return !stop;
        }
    }];
}


@end
