//
//  CBForestIndex.m
//  CBForest
//
//  Created by Jens Alfke on 4/1/14.
//  Copyright (c) 2014 Couchbase. All rights reserved.
//

#import "CBForestIndex.h"
#import "CBForestPrivate.h"
#import "CBLCollateJSON.h"
#import <forestdb.h>


static int indexCmp(void *a, void *b) {
    return CBLCollateJSON(NULL, INT_MAX, a, INT_MAX, b);
}


id kCBForestIndexNoValue;


@implementation CBForestIndex


+ (void) initialize {
    if (!kCBForestIndexNoValue)
        kCBForestIndexNoValue = [[NSObject alloc] init];
}


- (id) initWithFile: (NSString*)filePath
           readOnly: (BOOL)readOnly
              error: (NSError**)outError
{
    self = [super initWithFile: filePath readOnly: readOnly error: outError];
    if (self) {
        fdb_set_custom_cmp(self.db, &indexCmp);
    }
    return self;
}


- (BOOL) commit: (NSError**)outError {
    //FIX: Overridden to skip fdb_flush_wal, because this would write the keys to the hb-trie,
    // and the trie is incompatible with custom comparators. :-(
    // This is an issue that needs to be fixed in ForestDB (MB-10786).

    return Check(fdb_commit(self.db), outError);
}


- (BOOL) setKeys: (NSArray*)keys
          values: (NSArray*)values
     forDocument: (NSString*)docID
           error: (NSError**)outError
{
    // Remove any old key/value pairs previously generated by this document:
    NSData* docIDData = JSONToData(docID, NULL);
    NSData* seqData;
    if (![self getValue: &seqData meta: NULL forKey: docIDData error: outError])
        return NO;
    if (seqData) {
        NSArray* oldSeqs = DataToJSON(seqData, outError);
        for (NSNumber* seq in oldSeqs) {
            NSLog(@"INDEX: Deleting seq %@ for doc %@", seq, docID);
            [self deleteSequence: seq.unsignedLongLongValue error: outError];
        }
    }

    // Add the key/value pairs:
    NSUInteger count = keys.count;
    if (count > 0) {
        NSMutableArray* seqs = [[NSMutableArray alloc] initWithCapacity: count];
        NSMutableArray* realKey = [[NSMutableArray alloc] initWithObjects: [NSNull null], docID, nil];
        for (NSUInteger i = 0; i < count; i++) {
            realKey[0] = keys[i];
            if (i == 1)
                [realKey addObject: @(1)];
            else if (i > 1)
                realKey[2] = @(i);
            NSData* keyData = JSONToData(realKey, outError);
            if (!keyData)
                return NO;

            NSData* valueData = nil;
            id value = values[i];
            if (value != kCBForestIndexNoValue) {
                valueData = JSONToData(value, outError);
                if (!valueData)
                    return NO;
            }

            uint64_t seq = [self setValue: valueData meta: nil forKey: keyData error: outError];
            if (seq == SEQNUM_NOT_USED)
                return NO;
            [seqs addObject: @(seq)];
            NSLog(@"INDEX: Seq %llu = %@ (docID %@)", seq, realKey, docID);
        }
        seqData = JSONToData(seqs, NULL);
    } else {
        seqData = nil;
    }

    // Update the list of sequences used for this document:
    return [self setValue: seqData
                     meta: nil
                   forKey: docIDData
                    error: outError];
}


- (BOOL) queryStartKey: (id)startKey
                endKey: (id)endKey
               options: (const CBForestEnumerationOptions*)options
                 error: (NSError**)outError
                 block: (CBForestQueryCallbackBlock)block
{
    NSData* startKeyData = JSONToData([NSArray arrayWithObjects: startKey, nil], outError);
    NSData* endKeyData = nil;
    if (endKey) {
        endKeyData = JSONToData(@[endKey, @{}], outError);
        if (!endKeyData)
            return NO;
    }
    return [self _enumerateValuesFromKey: startKeyData toKey: endKeyData
                                 options: 0
                                   error: outError
                               withBlock: ^BOOL(const fdb_doc *doc, uint64_t bodyOffset)
    {
        NSArray* realKey = BufToJSON((sized_buf){doc->key, doc->keylen}, NULL);
        if (options && !options->inclusiveEnd && endKey && [endKey isEqual: realKey[0]]) {
            return false;
        }
        BOOL stop = NO;
        block(realKey[0], realKey[1], BufToData(doc->body, doc->bodylen), &stop);
        return !stop;
    }];
}


@end
